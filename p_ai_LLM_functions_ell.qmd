


```{python}
import ell
import openai
import os
import numpy as np
my_client = openai.Client(api_key=os.getenv("OPENAI_API_KEY"))

```

# Fixed Questions 

```{python}
@ell.simple(model="gpt-4o-mini", client=my_client)
def chat(message):
    return message
```

```{python}
response = chat("What is the most tourist-friendly city in France?")
```

Print for better readability.
```{python}
print(response)
```

# Variable Questions 

```{python}
countries = ["Nigeria", "Chile", "France", "Canada"]


@ell.simple(model="gpt-4o-mini", client=my_client)
def city_rec(country):
    return f"What is the most tourist-friendly city in {country}?"

city_rec_vec = np.vectorize(city_rec)
```

```{python}
for country in countries:
    print(city_rec(country))
```


```{python}
from concurrent.futures import ThreadPoolExecutor

# Run in parallel with simplified syntax
with ThreadPoolExecutor() as executor:
    x = executor.map(city_rec, country_df['country'])

list(x)
```

# Use in a dataframe 

```{python}
import pandas as pd
country_df = pd.DataFrame({"country": countries})
country_df
```


Using the vectorize method:

```{python}
country_df['city'] = city_rec_vec(country_df['country'])
```

Or using the apply method:


```{python}
country_df['city'] = country_df['country'].apply(city_rec)
country_df
```


# Two variables

```{python}
import ell
import openai
import os
import numpy as np
import pandas as pd

my_client = openai.Client(api_key=os.getenv("OPENAI_API_KEY"))

# Define the variables
attraction_types = ["restaurant", "hotel"]
cities = ["Paris", "Tokyo", "New York"]

# Create function that takes two parameters
@ell.simple(model="gpt-4o-mini", client=my_client)
def attraction_rec(attraction_type, city):
    return f"What is the best {attraction_type} to visit in {city}?"

# Vectorize the function
attraction_rec_vec = np.vectorize(attraction_rec)

# Create dataframe with all combinations
df = pd.DataFrame([(type, city) for type in attraction_types for city in cities],
                 columns=['attraction_type', 'city'])

# Apply vectorized function
df['recommendation'] = attraction_rec_vec(df['attraction_type'], df['city'])
df


# Or using the apply method:

df['recommendation'] = df.apply(lambda row: attraction_rec(row['attraction_type'], row['city']), axis=1)
df
```


# Structured outputs

UNtil recently, to get structured outputs, you would beg the model saying PLEASE RETURN ONE WORD ONLY AND THIS MUST BE A CITY AND IT MUST CONTAIN NO NUMBERS... And so on. But significantly easier these days. 

With structured outputs, you define the output format. 

```{python}
from pydantic import BaseModel, Field


# Define the structured output model
class Rec(BaseModel):
    city: str = Field(description="The name of the city")


# Define the function with structured output
@ell.complex(model="gpt-4o-mini", client=my_client, response_format=Rec)
def city_rec_clean(country):
    return f"What is the most tourist-friendly city in {country}?"
```

```{python}
recommendation = city_rec_clean("United Kingdom")
recommendation
```

```{python}
recommendation.parsed.city
```

Now use this in a dataframe.

```{python}
country_df['city'] = country_df['country'].apply(lambda country: city_rec_clean(country).parsed.city)
country_df
```

Yaay! 

Now let's get more information about the city. Rating out of 5. And best season to visit (FIX the options to be only 4 seasons).


```{python}
from pydantic import BaseModel, Field
from enum import Enum


class Season(str, Enum):
    spring = "Spring (Feb to May)"
    summer = "Summer (June to August)"
    autumn = "Autumn (September to November)"
    winter = "Winter (December to February)"


class RecDetail(BaseModel):
    city: str = Field(description="The name of the city")
    safety: int = Field(description="Safety rating out of 10")
    best_season: Season = Field(description="Best season to visit")


@ell.complex(model="gpt-4o-mini", client=my_client, response_format=RecDetail)
def city_rec_detail(country):
    return f"""What is the most tourist-friendly city in {country}? 
    Provide the city name, a safety rating, and the best season to visit."""
```

```{python}
# Test the function with a country
recommendation = city_rec_detail("United Kingdom")
print(recommendation.parsed)
```

```{python}
# Use in a dataframe
country_df['city'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.city)
country_df['safety'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.safety)
country_df['best_season'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.best_season.value)
country_df
```

# Advanced (optional). Parallel processing. 