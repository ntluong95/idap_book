


```{python}
import ell
import openai
import os

my_client = openai.Client(api_key=os.getenv("OPENAI_API_KEY"))

```

# Fixed Questions 

```{python}
@ell.simple(model="gpt-4o-mini", client=my_client)
def chat(message):
    return message
```

```{python}
response = chat("What is the most tourist-friendly city in France?")
```

Print for better readability.
```{python}
print(response)
```

# Variable Questions 

```{python}
countries = ["Nigeria", "Chile", "France", "Canada"]


@ell.simple(model="gpt-4o-mini", client=my_client)
def city_rec(country):
    return f"What is the most tourist-friendly city in {country}?"
```

```{python}
for country in countries:
    print(city_rec(country))
```


# Use in a dataframe 

```{python}
import pandas as pd
country_df = pd.DataFrame({"country": countries})
country_df
```

```{python}
city_df = country_df.assign(city = lambda x: x.country.apply(city_rec))
city_df
```


# Structured outputs

UNtil recently, to get structured outputs, you would beg the model saying PLEASE RETURN ONE WORD ONLY AND THIS MUST BE A CITY AND IT MUST CONTAIN NO NUMBERS... And so on. But significantly easier these days. 

With structured outputs, you define the output format. 

```{python}
from pydantic import BaseModel, Field


# Define the structured output model
class Rec(BaseModel):
    city: str = Field(description="The name of the city")


# Define the function with structured output
@ell.complex(model="gpt-4o-mini", client=my_client, response_format=Rec)
def city_rec_clean(country):
    return f"What is the most tourist-friendly city in {country}?"
```

```{python}
recommendation = city_rec_clean("United Kingdom")
recommendation
```

```{python}
recommendation.parsed.city
```

Now use this in a dataframe.

```{python}
country_df['city'] = country_df['country'].apply(lambda country: city_rec_clean(country).parsed.city)
country_df
```

Yaay! 

Now let's get more information about the city. Rating out of 5. And best season to visit (FIX the options to be only 4 seasons).


```{python}
from pydantic import BaseModel, Field
from enum import Enum


class Season(str, Enum):
    spring = "Spring (Feb to May)"
    summer = "Summer (June to August)"
    autumn = "Autumn (September to November)"
    winter = "Winter (December to February)"


class RecDetail(BaseModel):
    city: str = Field(description="The name of the city")
    safety: int = Field(description="Safety rating out of 10")
    best_season: Season = Field(description="Best season to visit")


@ell.complex(model="gpt-4o-mini", client=my_client, response_format=RecDetail)
def city_rec_detail(country):
    return f"""What is the most tourist-friendly city in {country}? 
    Provide the city name, a safety rating, and the best season to visit."""
```

```{python}
# Test the function with a country
recommendation = city_rec_detail("United Kingdom")
print(recommendation.parsed)
```

```{python}
# Use in a dataframe
country_df['city'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.city)
country_df['safety'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.safety)
country_df['best_season'] = country_df['country'].apply(lambda country: city_rec_detail(country).parsed.best_season.value)
country_df
```

# Advanced (optional). Parallel processing. 