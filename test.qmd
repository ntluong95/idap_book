CONSIDER THE FOLLOWING WORKSHOP. 

I would like to create another similar workshop for my next set of lessons. 

My next set of lessons covers data viz taxonomies, multivariate visualization and for loops. The lessons for those are pasted below.

Help draft the workshop.


```{python}
import pandas as pd
import plotly.express as px

ames = pd.read_csv("/Users/kendavidn/Dropbox/Mac (2)/Downloads/ames.csv")
ames.columns = ames.columns.str.replace(".", "_")
```


# Part 1: 

Consider the following questions about the Ames housing dataset. For each question, create a simple plot that addresses the question. Your plots do not have to be elegant, you will only be graded on whether you have picked the right types of visualizations to address each question. (No need to customize axes, labels, etc.)

0. What is the relationship between the size of the house and the price? (This will be done for you in class.)
    - Variables: `Lot_Area`, `price`
1. Are houses originally built earlier in the 1900s more expensive than those built later in the century?
    - Variables: `Year_Built`, `price`
2. What is the most common type of primary exterior material?
    - Variable: `Exterior_1st`
3. How does the price vary across different exterior types?
    - Variables: `Exterior_1st`, `price`
4. Which neighborhoods have the highest proportions of Single-family Detached homes?
    - Variables: `Neighborhood`, `Bldg_Type`

# Part 1 Solutions:

```{python}
# 0. What is the relationship between the size of the house and the price? (This will be done for you in class.)
px.scatter(ames, x="Lot_Area", y="price")

# Are houses originally built earlier in the 1900s more expensive than those built later in the century?
px.scatter(ames, x="Year_Built", y="price")  # keep

# What is the most common type of primary exterior material?
px.histogram(ames, x="Exterior_1st")  # keep

# How does the price vary across different exterior types?
px.box(ames, x="Exterior_1st", y="price")  # keep

# Which neighborhoods have the highest proportions of Single-family Detached homes?
px.histogram(
    ames, x="Neighborhood", color="Bldg_Type", barmode="stack", barnorm="percent"
)  # keep
```

# Part 2: Fixing errors

The following code chunk attempts to create a stacked bar chart of the `Central_Air` variable, but it contains several syntax errors. Your task is to correct the errors and improve the readability of the code.

```{python}
# First we use the replace method to change values according to the mapping
# We have not taught this yet, but you should be able to read and understand the gist of it

# Define a dictionary to map the values (replace with their full names)
heating_qc_labels = {
    "Ex": "Excellent",
    "Gd": "Good",
    "TA": "Average/Typical",
    "Fa": "Fair",
    "Po": "Poor",
}

central_air_labels = {
    "Y": "Central Air Conditioning",
    "N": "No Central Air Conditioning",
}

# Apply the mapping to the DataFrame
ames = ames.assign(
    Heating_QC_full=lambda df: df.Heating_QC.replace(heating_qc_labels),
    Central_Air_full=lambda df: df.Central_Air.replace(central_air_labels),
)

# Create the plot with the updated DataFrame
fig = px.histogram(
    ames,
    y="Central_Air_full",
    color="Heating_QC_full",
    barnorm="percent",
    color_discrete_sequence=["#d9534f", "#e39283", "#e8c590", "#a3c9a8", "#5cb85c"],
    category_orders={
        "Heating_QC_full": ["Poor", "Fair", "Average/Typical", "Good", "Excellent"],
        "Central_Air_full": ["No Central Air Conditioning", "Central Air Conditioning"],
    },
    labels={
        "Central_Air_full": "",
        "Heating_QC_full": "Heating Quality",
    },
    title="Central Air Conditioning by Heating Quality in Ames Housing",
)
fig
```

# Part 2b: Garage condition by garage location

Following the example above, create a horizontal percent-stacked bar chart showing the relationship between the type of exterior wall material (`Exterior_1st`) and the condition of the exterior wall (`Exter_Cond`). 

Your y axis should be the `Exterior_1st` variable, and the values should have their full names shown on the plot.

The x axis should be the `Exter_Cond` variable, and the values should also show the full names on the plot.

Feel free to use the same color scheme as in the example above. 

Your plot should have an appropriate title.

# Part 2b Solution:

```{python}
# Define the mapping for replacing values
exterior_type_labels = {
    "AsbShng": "Asbestos Shingles",
    "AsphShn": "Asphalt Shingles",
    "BrkComm": "Brick Common",
    "BrkFace": "Brick Face",
    "CBlock": "Cinder Block",
    "CemntBd": "Cement Board",
    "HdBoard": "Hard Board",
    "ImStucc": "Imitation Stucco",
    "MetalSd": "Metal Siding",
    "Other": "Other",
    "Plywood": "Plywood",
    "PreCast": "PreCast",
    "Stone": "Stone",
    "Stucco": "Stucco",
    "VinylSd": "Vinyl Siding",
    "Wd Sdng": "Wood Siding",
    "WdShing": "Wood Shingles",
}

exterior_cond_labels = {
    "Ex": "Excellent",
    "Gd": "Good",
    "TA": "Average/Typical",
    "Fa": "Fair",
    "Po": "Poor",
}

# Apply the mapping to the DataFrame
ames = ames.assign(
    Exterior_Type_full=lambda df: df.Exterior_1st.replace(exterior_type_labels),
    Exterior_Cond_full=lambda df: df.Exter_Cond.replace(exterior_cond_labels),
)

# Create the plot with the updated DataFrame
fig = px.histogram(
    ames,
    y="Exterior_Type_full",
    color="Exterior_Cond_full",
    barnorm="percent",
    color_discrete_sequence=["#d9534f", "#e39283", "#e8c590", "#a3c9a8", "#5cb85c"],
    category_orders={
        "Exterior_Cond_full": ["Poor", "Fair", "Average/Typical", "Good", "Excellent"],
        "Exterior_Type_full": sorted(ames["Exterior_Type_full"].unique()),
    },
    labels={
        "Exterior_Type_full": "Exterior Type",
        "Exterior_Cond_full": "Exterior Condition",
    },
    title="Exterior Condition by Exterior Type in Ames Housing",
)

fig.show()

```

# Part 3: Visualization with a For Loop

The plot below shows the distribution of the Roof style (`Roof_Style`) variable faceted by the slope of the property (`Land_Slope`).

```{python}
px.histogram(ames, x="Roof_Style", color="Land_Slope", facet_col="Land_Slope")
```

Recreate the same set of plots but using a for loop to iterate over the `Land_Slope` variable. The values for land slope are: 

Gtl:	Gentle slope
Mod:	Moderate Slope	
Sev:	Severe Slope

# Part3 Solution

```{python}
for land_slope in ["Gtl", "Mod", "Sev"]:
    ames_slope = ames.query(f"Land_Slope == '{land_slope}'")
    fig = px.histogram(
        ames_slope,
        x="Roof_Style",
        title=f"Roof Style Distribution for {land_slope} Land Slope",
    )
    fig.show()
```


# Part 4: Multivariate Plot Individual Assignment

Look through the dataset and decide on three or four variables that could be visualized on a single plot (or on a faceted plot). 

Create a multivariate plot that visualizes these variables and interpret any findings you can deduce from the plot.






Garage Type (Nominal): Garage location
		
       2Types	More than one type of garage
       Attchd	Attached to home
       Basment	Basement Garage
       BuiltIn	Built-In (Garage part of house - typically has room above garage)
       CarPort	Car Port
       Detchd	Detached from home
       NA	No Garage
		
Garage Yr Blt (Discrete): Year garage was built
		
Garage Finish (Ordinal)	: Interior finish of the garage

       Fin	Finished
       RFn	Rough Finished	
       Unf	Unfinished
       NA	No Garage
		
Garage Cars (Discrete): Size of garage in car capacity

Garage Area (Continuous): Size of garage in square feet

Garage Qual (Ordinal): Garage quality

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage
		
Garage Cond (Ordinal): Garage condition

       Ex	Excellent
       Gd	Good
       TA	Typical/Average
       Fa	Fair
       Po	Poor
       NA	No Garage

# Solution to Part 2

```{python}
px.histogram(
    ames, y="Exterior_1st", color="Exter_Qual", barmode="stack", barnorm="percent"
)
```

```{python}
# Create a stacked histogram of the `Central_Air` variable
fig = px.histogram(
    ames,
    x="Central_Air",
    color="Heating_QC",
    barmode="stack",
```





---
title: "Workshop: Data Structures and Visualizations with Financial Independence Survey Data"
---

## Introduction

In this workshop, you'll apply your knowledge of Python data structures, debugging, and data visualization.

In the first section, you'll practice identifying data structures and debugging code.

In the second section, you'll recreate two plots from a survey of Reddit users pursuing financial independence. 

In the third section, you'll each create your own two univariate plots on the same dataset.

In the fourth, optional challenge section, you'll attempt a bivariate or multivariate plot on your own.

The first two sections should be completed together in your group. The last two sections can be completed individually.

## Part 1: Understanding Data Structures and Debugging Code

Consider the following Python script:

```{python}
import pandas as pd

ages = [28, 34, 29, 45, 23, 38, 31, 40, 27, 50]
names = ["Ally", "Bob", "Char", "Dav", "Eve", "Fran", "Grace", "Han", "Ivy", "Jo"]

survey_data = {"Age": ages, "Name": names}

survey_df = pd.DataFrame(survey_data)
survey_df.head()
```

Identify the data structures used in the script above:

- What type of data structure is `ages`? : ANSWER HERE
- What data type is each element in `ages`? : ANSWER HERE
- What type of data structure is `names`? : ANSWER HERE
- What data type is each element in `names`? : ANSWER HERE
- What type of data structure is `survey_data`? : ANSWER HERE
- What type of data structure is `survey_df`? : ANSWER HERE


The chunk below attempts to create a histogram of respondent ages in `survey_df` but contains several syntax errors:

```{python}
#| eval: false
import plotly.express as px
fig = px.histogram(survey_df x='Age' title="Age Distribution of Respondents',
                   labels={'Age': 'Respondent Age' 'count': 'Number of Respondents},
                   color_discrete_sequence=#3366CC')
fig.show()
```

a. Identify and correct the syntax errors in the script so that it runs correctly.

b. Run the corrected code and observe the output.

c. Interpret the histogram. (Describe the distribution of ages in the sample.)

ANSWER HERE

## Part 2: Plot Reproduction

For this section, please visit [this link](https://the-graph-courses.github.io/pbb_q4_2024_materials/week_02_workshop/pbb_week_02_workshop_reddit_finance_plots) to see the plots you will be recreating.

These plots were created using the `reddit_finance` dataset, which you have been sent. 

The `reddit_finance` dataset contains survey responses from Reddit users who are in the r/financialindependence subreddit (online community). 
They are part of a movement of people who hope to save enough money to become financially independent early in life, so they can focus on other goals.
You can find out more about the dataset [here](https://vincentarelbundock.github.io/Rdatasets/doc/openintro/reddit_finance.html).
(As a side note, the in-demand data and tech skills you are learning in this program could be useful for your own financial goals!)

You need to upload the dataset to your Google Drive and then access it in this Colab notebook. 

There are two plots to recreate:

1. A horizontal bar chart of industry distribution
2. A treemap of industry distribution

We have not taught you how to use the treemap function yet, so you may will need to explore the documentation with `px.treemap?`. One hint: your main function call should include this: `px.treemap(df, path=['industry'])`.

Try your best to match the provided plots in terms of:

- Sorting
- Labels
- Colors (approximately)
- Overall aesthetics

START YOUR ANSWER HERE:

```{python}
# | eval: false
```

### Part 3: Individual Exploration

For this section, you will work individually. Your chosen plots should not be the same as those of your group members.

Before you start, to help with understanding the column names, please visit [this link](https://vincentarelbundock.github.io/Rdatasets/doc/openintro/reddit_finance.html).

a. Individually, select **two** other interesting columns from the `reddit_finance` dataset. This should include one categorical variable and one numeric/quantitative variable.

b. For each selected column, create an **elegant univariate plot** to visualize its distribution.

- For **categorical variables**, consider using bar charts, pie charts, or treemaps.
- For **quantitative variables**, consider using histograms, box plots, or violin plots.

c. Customize your plots with:

- Appropriate titles and axis labels.
- Customized colors or themes.
- Any additional annotations or features that enhance the visualization.

d. Write a brief interpretation for each plot, explaining any interesting insights or observations.

START YOUR ANSWERS HERE:

```{python}
# | eval: false
```

### Part 4: Optional Challenge (Ungraded)

Although we haven't covered bivariate or multivariate plots yet, you can experiment with creating one informative bivariate or multivariate plot using the plotly express functions.

For example, create a scatter plot, or a stacked bar plot. Feel free to consult the function documentation, Google or ChatGPT.

------

---
title: "Data Visualization Types"
---

This lesson covers a basic taxonomy of data visualization types and how to create them using Plotly. It is best consumed in video format. This written lesson is here just for quick reference.

First we show the different types of data visualization types. Then we show how to create each type of visualization using Plotly.

# Slides

![Slide 1](slides/data_viz_types/Slide1.jpeg)
![Slide 2](slides/data_viz_types/Slide2.jpeg)
![Slide 3](slides/data_viz_types/Slide3.jpeg)
![Slide 4](slides/data_viz_types/Slide4.jpeg)
![Slide 5](slides/data_viz_types/Slide5.jpeg)
![Slide 6](slides/data_viz_types/Slide6.jpeg)
![Slide 7](slides/data_viz_types/Slide7.jpeg)
![Slide 8](slides/data_viz_types/Slide8.jpeg)
![Slide 9](slides/data_viz_types/Slide9.jpeg)
![Slide 10](slides/data_viz_types/Slide10.jpeg)
![Slide 11](slides/data_viz_types/Slide11.jpeg)
![Slide 12](slides/data_viz_types/Slide12.jpeg)
![Slide 13](slides/data_viz_types/Slide13.jpeg)
![Slide 14](slides/data_viz_types/Slide14.jpeg)


# Code

```{python}
import plotly.express as px
import pandas as pd
import numpy as np
import plotly.io as pio

# Create a custom template
custom_template = pio.templates["plotly_white"]
custom_template.layout.update(
    font=dict(size=40),  # Increase the default font size
    title=dict(font=dict(size=45)),  # Increase title font size
    xaxis=dict(title=dict(font=dict(size=40)), tickfont=dict(size=30)),  # Increase x-axis title font size
    yaxis=dict(title=dict(font=dict(size=40)), tickfont=dict(size=30)),  # Increase y-axis title font size
    colorway=["#2f828a"]  # Set default color
)

# Set the custom template as default
pio.templates.default = custom_template

tips = px.data.tips()
```

# Univariate Graphs

## Numeric

```{python}
px.histogram(tips, x='tip')
```

```{python}
px.box(tips, x='tip')
```

```{python}
px.violin(tips, x='tip', box=True, points="all")
```

# Categorical

```{python}
sex_categ = px.histogram(tips, x='sex', color='sex', color_discrete_sequence= ['#deb221', '#2f828a'])
# remove the legend
sex_categ.update_layout(showlegend=False)
```

```{python}
# pie
pie_categ = px.pie(tips, values='tip', names='sex', color='sex', color_discrete_sequence=['#deb221', '#2f828a'])
pie_categ.update_layout(showlegend=False)
pie_categ.update_traces(textposition='none')
```

# Bivariate Graphs

## Numeric vs Numeric

```{python}
px.scatter(tips, x='total_bill', y='tip')
```

# Numeric vs Categorical

```{python}
# grouped histogram
px.histogram(tips, x='tip', color='sex', barmode='overlay', color_discrete_sequence= ['#deb221', '#2f828a'])
```

```{python}
# grouped violin plot
grouped_violin = px.violin(tips, y='sex', x='tip', color='sex', box=True, points="all", color_discrete_sequence= ['#deb221', '#2f828a'])
grouped_violin.update_layout(showlegend=False)
```

```{python}
# summary plot (e.g. mean + std tip by sex, bar plot)
# first calculate the mean and std in a single data frame with assign 
summary_df = tips.groupby('sex').agg({'tip': ['mean', 'std']}).reset_index()
summary_df.columns = ['sex', 'mean_tip', 'std_tip']

sex_bar =   px.bar(summary_df, y='sex', x='mean_tip', error_x='std_tip', color='sex', color_discrete_sequence=['#deb221', '#2f828a'])
sex_bar.update_layout(showlegend=False)
```

# Categorical vs Categorical


```{python}
# grouped bar plot
categ_categ_grouped_bar = px.histogram(tips, x='day', color='sex', barmode='group', color_discrete_sequence= ['#deb221', '#2f828a'])
categ_categ_grouped_bar.update_layout(showlegend=False)
```

```{python}
# stacked
categ_categ_stacked_bar = px.histogram(tips, x='day', color='sex', color_discrete_sequence= ['#deb221', '#2f828a'])
categ_categ_stacked_bar.update_layout(showlegend=False)
```

```{python}
# percent stacked
percent_stacked_df = (
    tips.groupby(["sex", "day"])
    .size()
    .reset_index(name='count')
    .assign(percent=lambda x: x.groupby('day')['count'].transform(lambda y: y / y.sum() * 100))
)

categ_categ_percent_stacked_bar = px.bar(
    percent_stacked_df,
    x="day",
    y="percent",
    color="sex",
    barmode="relative",
    color_discrete_sequence=["#deb221", "#2f828a"],
)
categ_categ_percent_stacked_bar.update_layout(showlegend=False)
```

```{python}
px.histogram(tips, x='day', color='sex', barmode='stack', barnorm='percent', color_discrete_sequence= ['#deb221', '#2f828a'])
```


# Practice

```{python}
gap_dat = px.data.gapminder()

gap_2007 = (gap_dat
    .query('year == 2007')
    .drop(columns=['year', 'iso_alpha', 'iso_num'])
    .assign(income_group=lambda df: np.where(df.gdpPercap > 15000, 'High Income', 'Low & Middle Income'))
)
```

1. How does country GDP per capita vary across continents?

```{python}
gdp_per_cap_violin = px.violin(
    gap_2007,
    x="gdpPercap",
    y="continent",
    color="continent",
    box=True,
    points="all",
    color_discrete_sequence=px.colors.qualitative.G10,
)

gdp_per_cap_violin.update_layout(showlegend=False)
```

2. Is there a relationship between GDP per capita & life expectancy?

```{python}
px.scatter(gap_2007, x='gdpPercap', y='lifeExp')
```


3. How does life expectancy vary between the income groups?

```{python}
px.strip(gap_2007, x="income_group", y="lifeExp")
px.violin(gap_2007, x="income_group", y="lifeExp", box=True, points="all")
```

4. What is the relationship between continent & income group?

```{python}
income_group_continent_bar = px.histogram(gap_2007, x='continent', color='income_group', barmode='stack', color_discrete_sequence= ['#deb221', '#2f828a'])
income_group_continent_bar.update_layout(showlegend=False)
```


# Time series

Nigeria population over time

```{python}
# as a bar chart
nigeria_pop = gap_dat.query('country == "Nigeria"')


# Bar chart
px.bar(nigeria_pop, x='year', y='pop')

# Line chart
px.line(nigeria_pop, x='year', y='pop')

# Line chart with points
px.line(nigeria_pop, x='year', y='pop', markers=True)
```



---
title: 'Bivariate & Multivariate Graphs with Plotly Express'
---

## Introduction

In this lesson, you'll learn how to create bivariate and multivariate graphs using Plotly Express. These types of graphs are essential for exploring relationships between two or more variables, whether they are quantitative or categorical. Understanding these relationships can provide deeper insights into your data.

Let's dive in!

## Learning Objectives

By the end of this lesson, you will be able to:

- Create scatter plots for quantitative vs. quantitative data
- Generate grouped histograms and violin plots for quantitative vs. categorical data
- Create grouped, stacked, and percent-stacked bar charts for categorical vs. categorical data
- Visualize time series data using bar charts and line charts
- Create bubble charts to display relationships between three or more variables
- Use faceting to compare distributions across subsets of data

## Imports

This lesson requires `plotly.express`, `pandas`, `numpy`, and `vega_datasets`. Install them if you haven't already.

```{python}
import plotly.express as px
import pandas as pd
import numpy as np
from vega_datasets import data
```

## Numeric vs. Numeric Data

When both variables are quantitative, scatter plots are an excellent way to visualize their relationship.

### Scatter Plot

Let's create a scatter plot to examine the relationship between `total_bill` and `tip` in the tips dataset. The tips dataset is included in Plotly Express and contains information about restaurant bills and tips that were collected by a waiter in a US restaurant.

First, we'll load the dataset and view the first five rows:

```{python}
tips = px.data.tips()
tips
```

Next, we'll create a basic scatter plot. We do this with the `px.scatter` function.

```{python}
px.scatter(tips, x='total_bill', y='tip')
```

From the scatter plot, we can observe that as the total bill increases, the tip amount tends to increase as well.

Let's enhance the scatter plot by adding labels and a title. 

```{python}
px.scatter(
    tips,
    x="total_bill",
    y="tip",
    labels={"total_bill": "Total Bill ($)", "tip": "Tip ($)"},
    title="Relationship Between Total Bill and Tip Amount",
)
```

Recall that you can see additional information about the function by typing `px.scatter?` in a cell and executing the cell. 

```{python}
# | eval: False
px.scatter?
```


::: {.callout-tip title='Practice'}

### Practice: Life Expectancy vs. GDP Per Capita

Using the Gapminder dataset (the 2007 subset, `g_2007`, defined below), create a scatter plot showing the relationship between `gdpPercap` (GDP per capita) and `lifeExp` (life expectancy).

According to the plot, what is the relationship between GDP per capita and life expectancy?

```{python}
gapminder = px.data.gapminder()
g_2007 = gapminder.query('year == 2007')
g_2007.head()
# Your code here
```

:::

## Numeric vs. Categorical Data

When one variable is quantitative and the other is categorical, we can use grouped histograms, violin plots, or box plots to visualize the distribution of the quantitative variable across different categories.

### Grouped Histograms

First, here's how you can create a regular histogram of all tips:

```{python}
px.histogram(tips, x='tip')
```

To create a grouped histogram, use the `color` parameter to specify the categorical variable. Here, we'll color the histogram by `sex`:

```{python}
px.histogram(tips, x='tip', color='sex')
```

By default, the histograms for each category are stacked. To change this behavior, you can use the `barmode` parameter. For example, `barmode='overlay'` will create an overlaid histogram:

```{python}
px.histogram(tips, x="tip", color="sex", barmode="overlay")
```

This creates two semi-transparent histograms overlaid on top of each other, allowing for direct comparison of the distributions.

::: {.callout-tip title='Practice'}

### Practice: Age Distribution by Gender

Using the `la_riots` dataset from `vega_datasets`, create a grouped histogram of `age` by `gender`. Compare the age distributions between different genders.

According to the plot, was the oldest victim male or female?

```{python}
la_riots = data.la_riots()
la_riots.head()
# Your code here
```

:::

### Violin & Box Plots

Violin plots are useful for comparing the distribution of a quantitative variable across different categories. They show the probability density of the data at different values and can include a box plot to summarize key statistics.

First, let's create a violin plot of all tips:

```{python}
px.violin(tips, y="tip")
```

We can add a box plot to the violin plot by setting the `box` parameter to `True`:

```{python}
px.violin(tips, y="tip", box=True)
```

For just the box plot, we can use `px.box`:

```{python}
px.box(tips, y="tip")
```

To add jitter points to the violin or box plots, we can use the `points = 'all'` parameter.

```{python}
px.violin(tips, y="tip", points="all")
```

Now, to create a violin plot of tips by gender, use the `x` parameter to specify the categorical variable:

```{python}
px.violin(tips, y="tip", x="sex", box=True)
```

We can also add a color axis to differentiate the violins:

```{python}
px.violin(tips, y="tip", x="sex", color="sex", box=True)
```

::: {.callout-tip title='Practice'}

### Practice: Life Expectancy by Continent

Using the `g_2007` dataset, create a violin plot showing the distribution of `lifeExp` by `continent`. 

According to the plot, which continent has the highest median country life expectancy?

```{python}
g_2007 = gapminder.query("year == 2007")
g_2007.head()
# Your code here
```

:::

### Summary Bar Charts (Mean and Standard Deviation)

Sometimes it's useful to display the mean and standard deviation of a quantitative variable across different categories. This can be visualized using a bar chart with error bars.

First, let's calculate the mean and standard deviation of tips for each gender. You have not yet learned how to do this, but you will in a later lesson.

```{python}
# Calculate the mean and standard deviation
summary_df = (
    tips.groupby("sex")
    .agg(mean_tip=("tip", "mean"), std_tip=("tip", "std"))
    .reset_index()
)
summary_df
```

Next, we'll create a bar chart using `px.bar` and add error bars using the `error_y` parameter:

```{python}
# Create the bar chart
px.bar(summary_df, x="sex", y="mean_tip", error_y="std_tip")
```

This bar chart displays the average tip amount for each gender, with error bars representing the standard deviation.

::: {.callout-tip title='Practice'}

### Practice: Average Total Bill by Day

Using the `tips` dataset, create a bar chart of mean `total_bill` by `day` with standard deviation error bars. You should copy and paste the code from the example above and modify it to create this plot.

According to the plot, which day has the highest average total bill?

```{python}
tips.head()  # View the tips dataset
# Your code here
```

:::


::: {.callout-note title='Side Note: Difference between `px.bar` and `px.histogram`'}

Notice that this is the first time we are using the `px.bar` function. For past plots, we have used `px.histogram` to make bar charts.

The bar chart function generally expects that the numeric variable being plotted is already in it's own column, while the histogram function does the grouping for you.

For example, in the cell below, we use `px.histogram` to make a bar chart of the `sex` column. The resulting plot compares the number of male and female customers in the dataset.

```{python}
px.histogram(tips, x='sex')
```

To make the same plot using `px.bar`, we first need to group by the `sex` column and count the number of rows for each sex.

```{python}
sex_counts = tips['sex'].value_counts().reset_index()
sex_counts
```

We can then plot the `day` column using `px.bar`:

```{python}
px.bar(sex_counts, x="sex", y="count")
```

This produces a bar chart with one bar for each sex.

:::


## Categorical vs. Categorical Data

When both variables are categorical, bar charts with a color axis are effective for visualizing the frequency distribution across categories. We will focus on three types of bar charts: stacked bar charts, percent-stacked bar charts, and grouped/clustered bar charts.

### Stacked Bar Charts

Stacked bar charts show the total counts and the breakdown within each category. To make a stacked bar chart, use the `color` parameter to specify the categorical variable:

```{python}
px.histogram(
    tips,
    x='day',
    color='sex'
)
```

Let's add numbers to the bars to show the exact counts, and also improve the color palette with custom colors.

```{python}
px.histogram(
    tips,
    x="day",
    color="sex",
    text_auto=True,
    color_discrete_sequence=["#deb221", "#2f828a"],
)
```

This stacked bar chart shows the total number of customers each day, broken down by gender.

::: {.callout-tip title='Practice'}

### Practice: High and Low Income Countries by Continent

Using the `g_2007_income` dataset, create a stacked bar chart showing the count of high and low income countries in each continent.

```{python}
gap_dat = px.data.gapminder()

g_2007_income = (
    gap_dat.query("year == 2007")
    .drop(columns=["year", "iso_alpha", "iso_num"])
    .assign(
        income_group=lambda df: np.where(
            df.gdpPercap > 15000, "High Income", "Low & Middle Income"
        )
    )
)

g_2007_income.head()
# Your code here
```

:::

### Percent-Stacked Bar Charts

To show proportions instead of counts, we can create percent-stacked bar charts by setting the `barnorm` parameter to `'percent'`:

```{python}
# Create the percent-stacked bar chart
px.histogram(tips, x="day", color="sex", barnorm="percent")
```

This chart normalizes the bar heights to represent percentages, showing the proportion of each gender for each day. 

We can also add text labels to the bars to show the exact percentages:

```{python}
px.histogram(tips, x="day", color="sex", barnorm="percent", text_auto=".1f")
```

The symbol `.1f` in the `text_auto` parameter formats the text labels to one decimal place.


::: {.callout-tip title='Practice'}

### Practice: Proportion of High and Low Income Countries by Continent

Again using the `g_2007_income` dataset, create a percent-stacked bar chart showing the proportion of high and low income countries in each continent. Add text labels to the bars to show the exact percentages.

According the plot, which continent has the highest proportion of high income countries? Are there any limitations to this plot?

```{python}
# Your code here
```

:::

### Clustered Bar Charts 

For clustered bar charts, set the `barmode` parameter to `'group'` to place the bars for each category side by side:

```{python}
px.histogram(tips, x="day", color="sex", barmode="group")
```

This layout makes it easier to compare values across categories directly.

## Time Series Data

Time series data represents observations collected at different points in time. It's crucial for analyzing trends, patterns, and changes over time. Let's explore some basic time series visualizations using Nigeria's population data from the Gapminder dataset.

First, let's prepare our data:

```{python}
# Load the Gapminder dataset
gapminder = px.data.gapminder()

# Subset the data for Nigeria
nigeria_pop = gapminder.query('country == "Nigeria"')[['year', 'pop']]
nigeria_pop
```

### Bar Chart

A bar chart can be used to plot time series data.

```{python}
# Bar chart
px.bar(nigeria_pop, x="year", y="pop")
```

This bar chart gives us a clear view of how Nigeria's population has changed over the years, with each bar representing the population at a specific year.

### Line Chart

A line chart is excellent for showing continuous changes over time:

```{python}
# Line chart
px.line(nigeria_pop, x="year", y="pop")
```

The line chart connects the population values, making it easier to see the overall trend of population growth.

Adding markers to a line chart can highlight specific data points:

```{python}
# Line chart with points
px.line(nigeria_pop, x='year', y='pop', markers=True)
```

We can also compare the population growth of multiple countries by adding a `color` parameter:

```{python}
nigeria_ghana = gapminder.query('country in ["Nigeria", "Ghana"]')
px.line(nigeria_ghana, x="year", y="pop", color="country", markers=True)
```

This chart allows us to compare the population trends of Nigeria and Ghana over time.

::: {.callout-tip title='Practice'}

### Practice: GDP per Capita Time Series

Using the Gapminder dataset, create a time series visualization for the GDP per capita of Iraq.

```{python}
# Your code here
```

What happened to Iraq in the 1980s that might explain the graph shown?

:::

## Plots with three or more variables

Although bivariate visualizations are the most common types of visualizations, plots with three or more variables are also sometimes useful. Let's explore a few examples.

### Bubble Charts

Bubble charts show the relationship between three variables by mapping the size of the points to a third variable. Below, we plot the relationship between `gdpPercap` and `lifeExp` with the size of the points representing the population of the country.

```{python}
px.scatter(g_2007, x="gdpPercap", y="lifeExp", size="pop")
```

We can easily spot the largest countries by population, such as China, India, and the United States. We can also add a color axis to differentiate between continents:

```{python}
px.scatter(g_2007, x="gdpPercap", y="lifeExp", size="pop", color="continent")
```

Now we have four different variables being plotted:

- `gdpPercap` on the x-axis
- `lifeExp` on the y-axis
- `pop` as the size of the points
- `continent` as the color of the points


::: {.callout-tip title='Practice'}

### Practice: Tips Bubble Chart

Using the `tips` dataset, create a bubble chart showing the relationship between `total_bill` and `tip` with the size of the points representing the `size` of the party, and the color representing the `day` of the week.

Use the plot to answer the question:

- The highest two tip amounts were on which days and what was the table size?

```{python}
tips.head()
# Your code here
```

:::

### Facet Plots

Faceting splits a single plot into multiple plots, with each plot showing a different subset of the data. This is useful for comparing distributions across subsets.

For example, we can facet the bubble chart by continent:

```{python}
px.scatter(
    g_2007,
    x="gdpPercap",
    y="lifeExp",
    size="pop",
    color="continent",
    facet_col="continent",
)
```

We can change the arrangement of the facets by changing the `facet_col_wrap` parameter. For example, `facet_col_wrap=2` will wrap the facets into two columns:

```{python}
px.scatter(
    g_2007,
    x="gdpPercap",
    y="lifeExp",
    size="pop",
    color="continent",
    facet_col="continent",
    facet_col_wrap=2,
)
```

Similarly, we can facet the violin plots of tips by day of the week:

```{python}
px.violin(
    tips,
    x="sex",
    y="tip",
    color="sex",
    facet_col="day",
    facet_col_wrap=2,
)
```

Faceting allows us to compare distributions across different days, providing more granular insights.

::: {.callout-tip title='Practice'}

### Practice: Tips Facet Plot

Using the `tips` dataset, create a percent-stacked bar chart of the `time` column, colored by the `sex` column, and facetted by the `day` column.

Which day-time has the highest proportion of male customers (e.g. Friday Lunch, Saturday Dinner, etc.)?
```{python}
tips.head()
# Your code here
```

:::

## Summary

In this lesson, you learned how to create bivariate and multivariate graphs using Plotly Express. Understanding these visualization techniques will help you explore and communicate relationships in your data more effectively.

See you in the next lesson!

---
title: 'Intro to Loops in Python'
---

## Introduction

At the heart of programming is the concept of repeating a task multiple times. A `for` loop is one fundamental way to do that. Loops enable efficient repetition, saving time and effort.

Mastering this concept is essential for writing intelligent Python code.

Let's dive in and enhance your coding skills!

## Learning Objectives

By the end of this lesson, you will be able to:

- Use basic `for` loops in Python
- Use index variables to iterate through lists in a loop
- Format output using f-strings within loops
- Apply loops to generate multiple plots for data visualization

## Packages

In this lesson, we will use the following Python libraries:

```{python}
import pandas as pd
import plotly.express as px
from vega_datasets import data
```

## Intro to `for` Loops

Let's start with a simple example. Suppose we have a list of children's ages in years, and we want to convert these to months:

```{python}
ages = [7, 8, 9]  # List of ages in years
```

We could try to directly multiply the list by 12:

```{python}
ages * 12
```

But this does not do what we want. It repeats the list 12 times.

Rather, we need to loop through each element in the list and multiply it by 12:

```{python}
for age in ages:
    print(age * 12)
```

`for` and `in` are required keywords in the loop. The colon and the indentation on the second line are also required.

In this loop, `age` is a temporary variable that takes the value of each element in `ages` during each iteration. First, `age` is 7, then 8, then 9.

You can choose any name for this variable:

```{python}
for random_name in ages:
    print(random_name * 12)
```

Note that we need the print statement since the loop does not automatically print the result: 

```{python}
for age in ages:
    age * 12
```

::: {.callout-tip title='Practice'}

### Hours to Minutes Basic Loop

Try converting hours to minutes using a `for` loop. Start with this list of hours:

```{python}
hours = [3, 4, 5]  # List of hours
# Your code here
```

:::

## Printing with f-strings

We might want to print both the result and the original age. We could do this by concatenating strings with the `+` operator. But we need to convert the age to a string with `str()`.

```{python}
for age in ages:
    print(str(age) + " years is " + str(age * 12) + " months" )
```

Alternatively, we can use something called an f-string. This is a string that allows us to embed variables directly.

```{python}
for age in ages:
    print(f"{age} years is {age * 12} months")
```

Within the f-string, we use curly braces `{}` to embed the variables.

::: {.callout-tip title='Practice'}

### Practice: F-String

Again convert the list of hours below to minutes. Use f-strings to print both the original hours and the converted minutes.

```{python}
hours = [3, 4, 5]  # List of hours
# Your code here
# Example output "3 hours is 180 minutes"
```

:::

## Are `for` Loops Useful in Python?

While `for` loops are useful, in many cases there are more efficient ways to perform operations over collections of data.

For example, our initial age conversion could be achieved using pandas Series:

```{python}
import pandas as pd

ages = pd.Series([7, 8, 9])
months = ages * 12
print(months)
```

But while libraries like pandas offer powerful ways to work with data, for loops are essential for tasks that can't be easily vectorized or when you need fine-grained control over the iteration process.

## Looping with an Index and Value

Sometimes, we want to access both the position (index) and the value of items in a list. The `enumerate()` function helps us do this easily.

Let's look at our `ages` list again:

```{python}
ages = [7, 8, 9]  # List of ages in years
```

First, let's see what `enumerate()` actually does:

```{python}
for item in enumerate(ages):
    print(item)
```

As you can see, `enumerate()` gives us pairs of (index, value).

We can unpack these pairs directly in the `for` loop:

```{python}
for i, age in enumerate(ages):
    print(f"The person at index {i} is aged {age}")
```

Here, `i` is the index, and `age` is the value at that index.

Now, let's create a more detailed output using both the index and value:

```{python}
for i, age in enumerate(ages):
    print(f"The person at index {i} is aged {age} years which is {age * 12} months")
```

This is particularly useful when you need both the position and the value in your loop.


::: {.callout-tip title='Practice'}

### Practice: Enumerate with F-strings

Use `enumerate()` and f-strings to print a sentence for each hour in the list:

```{python}
hours = [3, 4, 5]  # List of hours

# Your code here
# Example output: "Hour 3 at index 0 is equal to 180 minutes"
```

:::


# Real Loops Application: Generating Multiple Plots

Now that you have a solid understanding of `for` loops, let's apply our knowledge to a more realistic looping task: generating multiple plots.

We'll use  the `gapminder` dataset from Vega datasets to demonstrate this. Our aim is to create line plots for a few selected countries in the gapminder dataset.

First, let's load the data:

```{python}
# Load gapminder dataset
gapminder = data.gapminder()
gapminder.head()
```

Now let's create a line chart for a single country. We'll use the `query` method to filter the data for the country "Canada". We have not learned this method yet; it is a pandas function that allows us to filter the data based on a condition. We will learn more about it later in the course.

```{python}
# Filter data for China
china_data = gapminder.query("country == 'China'")

# Create line chart
fig = px.line(china_data, x="year", y="life_expect", title="Life Expectancy in China")
fig.show()
```

Now, let's create a loop to create line plots for a few selected countries.

```{python}
countries = ["India", "China", "United States", "Indonesia", "Pakistan"]

for country_name in countries:
    country_data = gapminder.query("country == @country_name")
    fig = px.line(
        country_data,
        x="year",
        y="life_expect",
        title=f"Life Expectancy in {country_name}",
    )
    fig.show()
```

This loop creates a separate line plot for each country in our list, showing how life expectancy has changed over time.

::: {.callout-tip title='Practice'}

### Practice: Population Over Time

Using the `gapminder` dataset, create a bar chart (with `px.bar`) of the population for the countries `United States`, `Canada`, `Mexico` and `Jamaica` over time.

```{python}
# Your code here
```

:::


::: {.callout-tip title='Practice'}

### Practice: Tips Histogram by Day

Using the `tips` dataset, create a histogram of the total bill for each day of the week.

```{python}
# Load tips dataset
tips = px.data.tips()
tips.head()
```


```{python}
# List of days
days = ["Thur", "Fri", "Sat", "Sun"]

# Your loop here
```

:::

# Wrap Up!

We've covered the very basics of `for` loops in Python, from simple syntax to practical data analysis applications. Loops are essential for efficient coding, allowing you to automate repetitive tasks. As we progress in the course, we will encounter many other applications of this key programming construct.
